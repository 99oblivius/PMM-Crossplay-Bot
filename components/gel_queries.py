# AUTOGENERATED FROM:
#     'queries/guild_set.edgeql'
#     'queries/guilds_get.edgeql'
#     'queries/map_create.edgeql'
#     'queries/map_disable.edgeql'
#     'queries/maps_get.edgeql'
#     'queries/mapvote_set.edgeql'
#     'queries/match_add_players.edgeql'
#     'queries/match_create.edgeql'
#     'queries/match_update.edgeql'
# WITH:
#     $ gel-py --tls-security insecure --target async --dir queries --file /srv/ValorsLeague/Database/tools/../../crossplay/crossplaybot/components/gel_queries.py


from __future__ import annotations
import dataclasses
import datetime
import gel
import uuid


MatchId = int
Snowflake = int
Snowflake02 = int


@dataclasses.dataclass
class GuildSetResult:
    id: uuid.UUID


@dataclasses.dataclass
class GuildsGetResult:
    updated_at: datetime.datetime | None
    created_at: datetime.datetime | None
    id: uuid.UUID
    guild_id: Snowflake02 | None
    queue_channel_id: Snowflake02 | None
    scores_channel_id: Snowflake02 | None
    staff_role_id: Snowflake02 | None
    readyup_channel_id: Snowflake02 | None
    readyup_message_id: Snowflake02 | None
    maps: list[GuildsGetResultMapsItem]


@dataclasses.dataclass
class GuildsGetResultMapsItem:
    updated_at: datetime.datetime | None
    created_at: datetime.datetime | None
    id: uuid.UUID
    name: str
    enabled: bool
    image_url: str
    order: int | None


@dataclasses.dataclass
class MapCreateResult:
    id: uuid.UUID
    order: int | None


@dataclasses.dataclass
class MapDisableResult:
    id: uuid.UUID


@dataclasses.dataclass
class MapvoteSetResult:
    id: uuid.UUID


@dataclasses.dataclass
class MatchAddPlayersResult:
    id: uuid.UUID


@dataclasses.dataclass
class MatchCreateResult:
    id: uuid.UUID
    num: MatchId | None


async def guild_set(
    executor: gel.AsyncIOExecutor,
    *,
    guild_id: Snowflake,
    scores_channel_id: Snowflake | None = None,
    queue_channel_id: Snowflake | None = None,
    readyup_channel_id: Snowflake | None = None,
    readyup_message_id: Snowflake | None = None,
    staff_role_id: Snowflake | None = None,
) -> GuildSetResult:
    return await executor.query_single(
        """\
        with
            guild_id := <Snowflake>$guild_id,
            scores_channel_id := <optional Snowflake>$scores_channel_id ?? <Snowflake>{},
            queue_channel_id := <optional Snowflake>$queue_channel_id ?? <Snowflake>{},
            readyup_channel_id := <optional Snowflake>$readyup_channel_id ?? <Snowflake>{},
            readyup_message_id := <optional Snowflake>$readyup_message_id ?? <Snowflake>{},
            staff_role_id := <optional Snowflake>$staff_role_id ?? <Snowflake>{}
        insert Guild {
            guild_id := guild_id,
            scores_channel_id := scores_channel_id,
            queue_channel_id := queue_channel_id,
            readyup_channel_id := readyup_channel_id,
            readyup_message_id := readyup_message_id,
            staff_role_id := staff_role_id
        }
        unless conflict on .guild_id
        else (
            update Guild set {
                scores_channel_id := scores_channel_id ?? .scores_channel_id,
                queue_channel_id := queue_channel_id ?? .queue_channel_id,
                readyup_channel_id := readyup_channel_id ?? .readyup_channel_id,
                readyup_message_id := readyup_message_id ?? .readyup_message_id,
                staff_role_id := staff_role_id ?? .staff_role_id
            }
        )\
        """,
        guild_id=guild_id,
        scores_channel_id=scores_channel_id,
        queue_channel_id=queue_channel_id,
        readyup_channel_id=readyup_channel_id,
        readyup_message_id=readyup_message_id,
        staff_role_id=staff_role_id,
    )


async def guilds_get(
    executor: gel.AsyncIOExecutor,
) -> list[GuildsGetResult]:
    return await executor.query(
        """\
        select Guild { ** }\
        """,
    )


async def map_create(
    executor: gel.AsyncIOExecutor,
    *,
    guild_id: Snowflake,
    name: str,
    image_url: str,
) -> MapCreateResult:
    return await executor.query_single(
        """\
        with
            guild := select Guild filter Guild.guild_id = <Snowflake>$guild_id,
            name := <str>$name,
            image_url := <str>$image_url,
            new_order := select max((select Map filter Map.guild = guild).order) + 1
        select (
            insert Map {
                guild := guild,
                `order` := new_order,
                name := name,
                image_url := image_url
            }
            unless conflict on (.guild, .name)
            else (
                update Map set {
                    `order` := new_order,
                    enabled := true,
                    image_url := image_url
                }
            )
        ) { `order` }\
        """,
        guild_id=guild_id,
        name=name,
        image_url=image_url,
    )


async def map_disable(
    executor: gel.AsyncIOExecutor,
    *,
    guild_id: Snowflake,
    name: str,
) -> MapDisableResult | None:
    return await executor.query_single(
        """\
        with
            guild := select Guild filter Guild.guild_id = <Snowflake>$guild_id,
            name := <str>$name
        update Map
        filter .guild = guild and .name = name and .enabled = true
        set {
            enabled := false
        }\
        """,
        guild_id=guild_id,
        name=name,
    )


async def maps_get(
    executor: gel.AsyncIOExecutor,
    *,
    guild_id: Snowflake,
) -> list[GuildsGetResultMapsItem]:
    return await executor.query(
        """\
        select `Map` { * }
        filter .guild = (select Guild filter Guild.guild_id = <Snowflake>$guild_id)
        and .enabled = true\
        """,
        guild_id=guild_id,
    )


async def mapvote_set(
    executor: gel.AsyncIOExecutor,
    *,
    match: uuid.UUID,
    player: uuid.UUID,
    map: uuid.UUID,
) -> MapvoteSetResult:
    return await executor.query_single(
        """\
        with
            `match` := <`Match`>$match,
            player := <Player>$player,
            map := <Map>$map
        insert MapVote {
            `match` := `match`,
            player := player,
            map := map
        }
        unless conflict on (.`match`, .player)
        else (
            update MapVote set {
                map := map
            }
        )\
        """,
        match=match,
        player=player,
        map=map,
    )


async def match_add_players(
    executor: gel.AsyncIOExecutor,
    *,
    teamA_ids: list[Snowflake],
    teamB_ids: list[Snowflake],
    num: int,
) -> MatchAddPlayersResult | None:
    return await executor.query_single(
        """\
        update `Match`
        filter .num = <int64>$num
        set {
            teamA_players += (
                select Player
                filter contains(<array<Snowflake>>$teamA_ids, Player.discord_id)
            ),
            teamB_players += (
                select Player
                filter contains(<array<Snowflake>>$teamB_ids, Player.discord_id)
            )
        }\
        """,
        teamA_ids=teamA_ids,
        teamB_ids=teamB_ids,
        num=num,
    )


async def match_create(
    executor: gel.AsyncIOExecutor,
    *,
    guild_id: Snowflake,
) -> MatchCreateResult:
    return await executor.query_single(
        """\
        select (
            insert `Match` {
                guild := select Guild filter Guild.guild_id = <Snowflake>$guild_id
            }
        ) { num }\
        """,
        guild_id=guild_id,
    )


async def match_update(
    executor: gel.AsyncIOExecutor,
    *,
    map: uuid.UUID | None = None,
    teamA_score: int | None = None,
    teamB_score: int | None = None,
    ended_ts: datetime.datetime | None = None,
    num: int,
) -> MatchAddPlayersResult | None:
    return await executor.query_single(
        """\
        update `Match`
        filter .num = <int64>$num
        set {
            map := <optional Map>$map ?? .map,
            teamA_score := <optional int64>$teamA_score ?? .teamA_score,
            teamB_score := <optional int64>$teamB_score ?? .teamB_score,
            ended_ts := <optional datetime>$ended_ts ?? .ended_ts
        }\
        """,
        map=map,
        teamA_score=teamA_score,
        teamB_score=teamB_score,
        ended_ts=ended_ts,
        num=num,
    )
